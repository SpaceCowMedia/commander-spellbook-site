name: "Startup Backend"
description: "Clone and run the backend service using docker compose"

inputs:
  port:
    required: true
    description: "The port on which the backend service will be accessible"

runs:
  using: composite
  steps:
    - name: Checkout üõéÔ∏è
      uses: actions/checkout@v6
      with:
        repository: "SpaceCowMedia/commander-spellbook-backend"
        ref: latest
        path: backend
    - name: Download Backend Docker Images üê≥
      uses: actions/github-script@v8
      with:
        script: |
          // Download release files from SpaceCowMedia/commander-spellbook-backend latest release
          const { data: release } = await github.rest.repos.getLatestRelease({
            owner: 'SpaceCowMedia',
            repo: 'commander-spellbook-backend',
          });
          const path = './backend/docker-images';
          const fs = require('fs');
          if (!await fs.promises.stat(path).catch(() => false)) {
            await fs.promises.mkdir(path, { recursive: true });
          }
          for (const asset of release.assets) {
            if (asset.name.endsWith('.tar')) {
              console.log(`Downloading ${asset.name}...`);
              const url = asset.browser_download_url;
              const filePath = `./backend/docker-images/${asset.name}`;
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error(`Failed to download ${asset.name}: ${response.statusText}`);
              }
              const buffer = await response.arrayBuffer();
              await fs.promises.writeFile(filePath, Buffer.from(buffer));
              console.log(`Downloaded ${asset.name} to ${filePath}`);
            }
          }
    - name: Load Docker Images üê≥
      shell: bash
      run: |
        for image in ./backend/docker-images/*.tar; do
          echo "Loading $image..."
          docker load -i "$image"
        done
    - name: Start Backend üöÄ
      env:
        PORT: ${{ inputs.port }}
      working-directory: ./backend
      shell: bash
      run: |
        docker compose config
        docker compose up -d
    - name: Wait for Backend to be ready ‚è±Ô∏è
      shell: bash
      run: |
        echo "Waiting for backend to be ready on port ${{ inputs.port }}..."
        i=0
        until curl -s http://localhost:${{ inputs.port }}/ --fail-with-body
        do
          echo "Backend not ready yet, waiting..."
          sleep 5
          i=$((i+1))
          if [ $i -gt 24 ]; then
            echo "Backend did not become ready in time, exiting."
            exit 1
          fi
        done
    - name: Seed Backend Database üå±
      working-directory: ./backend
      shell: bash
      run: |
        docker compose exec web python manage.py shell <<EOF
        from spellbook.models import ZoneLocation
        from spellbook.tasks import generate_variants_task, export_variants_task
        from django.conf import settings
        settings.TASKS = {"default": {"BACKEND": "django.tasks.backends.immediate.ImmediateBackend"}}
        Card.objects.all().delete()
        Template.objects.all().delete()
        Combo.objects.all().delete()
        Feature.objects.all().delete()
        Variant.objects.all().delete()
        c1 = Card.objects.create(
          id=1,
          name="Basalt Monolith",
          identity="C",
          color="C",
          oracle_id="6b8cf2a0-b045-4d91-9d91-c602d40c6237",
          type_line="Artifact",
          price_tcgplayer=4.99,
          spoiler=True,
        )
        c2 = Card.objects.create(
          id=2,
          name="Mesmeric Orb",
          identity="C",
          color="C",
          oracle_id="03efb4f3-b8e2-4441-824f-886dc40712c4",
          type_line="Artifact",
          price_tcgplayer=2.49,
        )
        c3 = Card.objects.create(
          id=3,
          name="Forsaken Monument",
          identity="C",
          color="C",
          oracle_id="7777fab1-df3f-467f-b9e2-46dd2bd2166e",
          type_line="Legendary Artifact",
          price_tcgplayer=12.99,
        )
        f1 = Feature.objects.create(
          id=1,
          name="Infinite mill",
        )
        f2 = Feature.objects.create(
          id=2,
          name="Infinite mana",
        )
        combo1 = Combo.objects.create(
          id=1,
          description="This is a sample combo.",
          easy_prerequisites="Easy prerequisites here.",
          notable_prerequisites="Notable prerequisites here.",
          notes="These are some notes about the combo.",
          status=Combo.Status.GENERATOR,
        )
        combo1.cardincombo_set.create(
          card=c1,
          zone_locations=ZoneLocation.BATTLEFIELD,
        )
        combo1.cardincombo_set.create(
          card=c2,
          zone_locations=ZoneLocation.BATTLEFIELD,
        )
        combo1.featureproducedincombo_set.create(
          feature=f1,
        )
        combo2 = Combo.objects.create(
          id=2,
          description="This is another sample combo.",
          easy_prerequisites="Easy prerequisites here.",
          notable_prerequisites="Notable prerequisites here.",
          notes="These are some notes about the combo.",
          status=Combo.Status.GENERATOR,
        )
        combo2.cardincombo_set.create(
          card=c1,
          zone_locations=ZoneLocation.BATTLEFIELD,
        )
        combo2.cardincombo_set.create(
          card=c3,
          zone_locations=ZoneLocation.BATTLEFIELD,
        )
        combo2.featureproducedincombo_set.create(
          feature=f2,
        )
        import time
        task = generate_variants_task.enqueue()
        while not task.is_finished:
          time.sleep(1)
          task.refresh()
        Variant.objects.update(status=Variant.Status.OK)
        task = export_variants_task.enqueue()
        while not task.is_finished:
          time.sleep(1)
          task.refresh()
        EOF
