const local_index = {"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Development Docs This documentation is rendered as a website on GitHub Pages . Any change to markdown files will be deployed after it gets merged into the main branch. Getting Started The site requires node v16 and npm 8 (which comes installed with node@16) to run locally, since it utilizes npm workspaces to structure the repo. If you are already using the Node Version Manager (nvm) tool, you can run nvm install in the directory to get the correct version of node. Once you have installed node, you can install the project's dependencies: npm install Frontend App Installation and setup Creating a new page Creating a component Backend API The backend (auth, api, database) is all managed by Firebase . Running the app locally Authentication/User Accounts Database Collections API Manual Deploys Automated Testing Unit Testing Integration Testing Note: There is currently an issue with firebase-tools@v11.19.0 that prevents the emulators from running . We pin firebase-tools to v11.18.0 until this is resolved.","title":"Development Docs"},{"location":"index.html#development-docs","text":"This documentation is rendered as a website on GitHub Pages . Any change to markdown files will be deployed after it gets merged into the main branch.","title":"Development Docs"},{"location":"index.html#getting-started","text":"The site requires node v16 and npm 8 (which comes installed with node@16) to run locally, since it utilizes npm workspaces to structure the repo. If you are already using the Node Version Manager (nvm) tool, you can run nvm install in the directory to get the correct version of node. Once you have installed node, you can install the project's dependencies: npm install","title":"Getting Started"},{"location":"index.html#frontend-app","text":"Installation and setup Creating a new page Creating a component","title":"Frontend App"},{"location":"index.html#backend-api","text":"The backend (auth, api, database) is all managed by Firebase . Running the app locally Authentication/User Accounts Database Collections API Manual Deploys","title":"Backend API"},{"location":"index.html#automated-testing","text":"Unit Testing Integration Testing Note: There is currently an issue with firebase-tools@v11.19.0 that prevents the emulators from running . We pin firebase-tools to v11.18.0 until this is resolved.","title":"Automated Testing"},{"location":"backend/SUMMARY.html","text":"Running the app locally Authentication/User Accounts Database Collections API Manual Deploys","title":"SUMMARY"},{"location":"backend/api.html","text":"API The backend/src/api directory dictates the public API and is written as an express application . All requests to the API validate the user's authorization token and attach the user id and permissions to the request. Routing /v1/site-settings/* /v1/user/* Site Settings For updating settings specific to the site, such as the featured combos. User For updating info about the user who is using the site. Middleware If a collection of routes all require the same validation (such as a user permission), write middleware for it. Succces Responses When reporting that a request is successful, use a status of 200 when the operation is complete and no changes were made (such as from a standard GET request) and a 201 when the operation caused a change to happen (such as from a standard POST request). Chain the status call with JSON indicating that the request was succesful and any other data that needs to be passed back in the request. // the request was succesful when no changes were made res . status ( 200 ). json ({ success : true , // whatever relevant data is being passed down foo : \"bar\" , }); // the request was succesful and a change was made in the DB res . status ( 201 ). json ({ success : true , // whatever relevant data is being passed down foo : \"bar\" , }); Error Handling JavaScript Error objects cannot be serialized meaningfully (It'll lose the message when turned into a JSON string), so instead we use a custom error object. Use the following status in the following circumstances: 400 - when required parameters are missing 422 - when required parameters are present, but in an incorrect form 403 - when the user does not have permission to do the operation 404 - when the requested resource is not present 500 - when it's a unknown error import { NotFoundError , PermissionError , UnknownError , ValidationError , } from \"../api/error\" ; // user does not have permission for this action res . status ( 403 ). json ( new PermissionError ( \"Custom error message\" )); // the resource could not be found res . status ( 403 ). json ( new NotFoundError ( \"Custom error message\" )); // a required post body param is missing res . status ( 400 ). json ( new ValidationError ( \"Custom error message\" )); // the required param is present, but it is in the wrong format res . status ( 422 ). json ( new ValidationError ( \"Custom error message\" )); // something went wrong, but we're not sure what it was res . status ( 500 ). json ( new UnknownError ( \"Custom error message\" ));","title":"API"},{"location":"backend/api.html#api","text":"The backend/src/api directory dictates the public API and is written as an express application . All requests to the API validate the user's authorization token and attach the user id and permissions to the request.","title":"API"},{"location":"backend/api.html#routing","text":"/v1/site-settings/* /v1/user/*","title":"Routing"},{"location":"backend/api.html#site-settings","text":"For updating settings specific to the site, such as the featured combos.","title":"Site Settings"},{"location":"backend/api.html#user","text":"For updating info about the user who is using the site.","title":"User"},{"location":"backend/api.html#middleware","text":"If a collection of routes all require the same validation (such as a user permission), write middleware for it.","title":"Middleware"},{"location":"backend/api.html#succces-responses","text":"When reporting that a request is successful, use a status of 200 when the operation is complete and no changes were made (such as from a standard GET request) and a 201 when the operation caused a change to happen (such as from a standard POST request). Chain the status call with JSON indicating that the request was succesful and any other data that needs to be passed back in the request. // the request was succesful when no changes were made res . status ( 200 ). json ({ success : true , // whatever relevant data is being passed down foo : \"bar\" , }); // the request was succesful and a change was made in the DB res . status ( 201 ). json ({ success : true , // whatever relevant data is being passed down foo : \"bar\" , });","title":"Succces Responses"},{"location":"backend/api.html#error-handling","text":"JavaScript Error objects cannot be serialized meaningfully (It'll lose the message when turned into a JSON string), so instead we use a custom error object. Use the following status in the following circumstances: 400 - when required parameters are missing 422 - when required parameters are present, but in an incorrect form 403 - when the user does not have permission to do the operation 404 - when the requested resource is not present 500 - when it's a unknown error import { NotFoundError , PermissionError , UnknownError , ValidationError , } from \"../api/error\" ; // user does not have permission for this action res . status ( 403 ). json ( new PermissionError ( \"Custom error message\" )); // the resource could not be found res . status ( 403 ). json ( new NotFoundError ( \"Custom error message\" )); // a required post body param is missing res . status ( 400 ). json ( new ValidationError ( \"Custom error message\" )); // the required param is present, but it is in the wrong format res . status ( 422 ). json ( new ValidationError ( \"Custom error message\" )); // something went wrong, but we're not sure what it was res . status ( 500 ). json ( new UnknownError ( \"Custom error message\" ));","title":"Error Handling"},{"location":"backend/database.html","text":"Firestore We use a NoSQL Firestore Database to hold the site's data. (currently, the combos still live in Google Sheets , but we intend to move that over to Firestor in the near future) Collections Current collections are: site-settings user-profiles usernames They can be used in the api via the database model abstractions found at /backend/db/*.ts . Site Settings This collection is for data on the site that may need to be updated by a user with the manageSiteContent permission. So far, the only document is featured-combos which includes the button text display on the home page for featured combos and determines the rules by which combos are selected to be featured. User Profiles This collection contains additional data about the user, such as the user's username. The key for each user-profile is the user id of the owner. Usernames This collection is to enforce a uniqueness constraint on the user's username. The key is the user's username, but with all lowercase letters and punctuation removed. Rules The firestore.rules file dictates the changes that can be made to documents in the Firestore database on the client. Warning: these rules do not apply when using functions along with the firebase-admin module. Typically, changes to the database will all run through the API (which use the firebase-admin module). Exceptions can happen for loading data into the site from a read-only model. (such as creating the featured combos page)","title":"Database Collections"},{"location":"backend/database.html#firestore","text":"We use a NoSQL Firestore Database to hold the site's data. (currently, the combos still live in Google Sheets , but we intend to move that over to Firestor in the near future)","title":"Firestore"},{"location":"backend/database.html#collections","text":"Current collections are: site-settings user-profiles usernames They can be used in the api via the database model abstractions found at /backend/db/*.ts .","title":"Collections"},{"location":"backend/database.html#site-settings","text":"This collection is for data on the site that may need to be updated by a user with the manageSiteContent permission. So far, the only document is featured-combos which includes the button text display on the home page for featured combos and determines the rules by which combos are selected to be featured.","title":"Site Settings"},{"location":"backend/database.html#user-profiles","text":"This collection contains additional data about the user, such as the user's username. The key for each user-profile is the user id of the owner.","title":"User Profiles"},{"location":"backend/database.html#usernames","text":"This collection is to enforce a uniqueness constraint on the user's username. The key is the user's username, but with all lowercase letters and punctuation removed.","title":"Usernames"},{"location":"backend/database.html#rules","text":"The firestore.rules file dictates the changes that can be made to documents in the Firestore database on the client. Warning: these rules do not apply when using functions along with the firebase-admin module. Typically, changes to the database will all run through the API (which use the firebase-admin module). Exceptions can happen for loading data into the site from a read-only model. (such as creating the featured combos page)","title":"Rules"},{"location":"backend/manual-deploys.html","text":"Deplopying to Firebase Before you start If you do not have access to the Firebase console for the project, you will not be able to deploy changes to the Firestore configuration and Functions. If you believe you should have access, discuss it with the moderators in the Commander Spellbook Discord server . Deploys First, log in to Firebase. (if you are not a member of the Firebase project you are attemptting to deploy to, you will be unable to do the deploys) npm run firebase:login Choose the environment you are deploying to: npm run firebase:deploy:local npm run firebase:deploy:staging npm run firebase:deploy:prod Whenever you deploy to staging or prod , it will auto switch back the context to local when it finishes. prod and local automatically deploy whenever the site is deployed via Github Actions .","title":"Manual Deploys"},{"location":"backend/manual-deploys.html#deplopying-to-firebase","text":"","title":"Deplopying to Firebase"},{"location":"backend/manual-deploys.html#before-you-start","text":"If you do not have access to the Firebase console for the project, you will not be able to deploy changes to the Firestore configuration and Functions. If you believe you should have access, discuss it with the moderators in the Commander Spellbook Discord server .","title":"Before you start"},{"location":"backend/manual-deploys.html#deploys","text":"First, log in to Firebase. (if you are not a member of the Firebase project you are attemptting to deploy to, you will be unable to do the deploys) npm run firebase:login Choose the environment you are deploying to: npm run firebase:deploy:local npm run firebase:deploy:staging npm run firebase:deploy:prod Whenever you deploy to staging or prod , it will auto switch back the context to local when it finishes. prod and local automatically deploy whenever the site is deployed via Github Actions .","title":"Deploys"},{"location":"backend/running-locally.html","text":"Running the App Locally By default, when you run the frontend app locally, it'll connect to a special Firebase app dedicated for local development of Commander Spellbook. This app gets updates deployed to it automatically whenever updates are deployed to the production Firebase app. If you do not need to make any changes to the backend Firebase code, you can just run the site normally , and it'll connect to the local development instance of Firebase. Emulators If you do need to make changes, you can do so by running the Firebase emulators to see your changes locally without deploying them. To run the functions, firestore and auth locally, first create or modify an .env file in the root of the repository with USE_FIREBASE_EMULATORS set to true and NODE_ENV set to development: USE_FIREBASE_EMULATORS = true NODE_ENV = development You will also need Java installed on your machine to run the emulators. Once those tasks are complete, run: npm run firebase:emulate The firebase emulators will start running. Once the frontend app is running, you should see a warning on the bottom of the screen of the app that it is using local emulators. Running the emulators will allow you to test changes without modifying any data or deploying changes to the local development instance of the Firebase project.","title":"Running the app locally"},{"location":"backend/running-locally.html#running-the-app-locally","text":"By default, when you run the frontend app locally, it'll connect to a special Firebase app dedicated for local development of Commander Spellbook. This app gets updates deployed to it automatically whenever updates are deployed to the production Firebase app. If you do not need to make any changes to the backend Firebase code, you can just run the site normally , and it'll connect to the local development instance of Firebase.","title":"Running the App Locally"},{"location":"backend/running-locally.html#emulators","text":"If you do need to make changes, you can do so by running the Firebase emulators to see your changes locally without deploying them. To run the functions, firestore and auth locally, first create or modify an .env file in the root of the repository with USE_FIREBASE_EMULATORS set to true and NODE_ENV set to development: USE_FIREBASE_EMULATORS = true NODE_ENV = development You will also need Java installed on your machine to run the emulators. Once those tasks are complete, run: npm run firebase:emulate The firebase emulators will start running. Once the frontend app is running, you should see a warning on the bottom of the screen of the app that it is using local emulators. Running the emulators will allow you to test changes without modifying any data or deploying changes to the local development instance of the Firebase project.","title":"Emulators"},{"location":"backend/users.html","text":"User Accounts Email Link We use the Firebase Email Link strategy for creating accounts and logging in. Basically, instead of having our users remember a password to log in, they simply enter their email and then click the link that gets emailed to them. That opens them back on the website and they are logged in! User Permissions After a user logs in for the first time, the site will automatically attempt to provision the user. This essentially means that the site will validate that the user's chosen username is available and then the user will be given the default permissions for actions on the site. Namely, the ability to propose new combos. Every time the user loads the user dashboard, the site will check if the user has already been provisioned, and then display the parts of the dashboard they are allowed to see. An administrator with the manageUsers permission can modify what a user is allowed to do as well as details about the user (such as display name, their email or username). Here are the following permissions a user can have: provisioned - when true , the user is created and ready to be used on the site. Not really used for anything other than to determine that the user is fully set up and the initial permissions have been set. proposeCombo - can submit new combos for review on the site manageUsers - can change the user permissions and user details of another user manageSiteContent - can change site settings, such as the parameters for what featured combos there are viewUsers - inspect, but not manage users","title":"Authentication/User Accounts"},{"location":"backend/users.html#user-accounts","text":"","title":"User Accounts"},{"location":"backend/users.html#email-link","text":"We use the Firebase Email Link strategy for creating accounts and logging in. Basically, instead of having our users remember a password to log in, they simply enter their email and then click the link that gets emailed to them. That opens them back on the website and they are logged in!","title":"Email Link"},{"location":"backend/users.html#user-permissions","text":"After a user logs in for the first time, the site will automatically attempt to provision the user. This essentially means that the site will validate that the user's chosen username is available and then the user will be given the default permissions for actions on the site. Namely, the ability to propose new combos. Every time the user loads the user dashboard, the site will check if the user has already been provisioned, and then display the parts of the dashboard they are allowed to see. An administrator with the manageUsers permission can modify what a user is allowed to do as well as details about the user (such as display name, their email or username). Here are the following permissions a user can have: provisioned - when true , the user is created and ready to be used on the site. Not really used for anything other than to determine that the user is fully set up and the initial permissions have been set. proposeCombo - can submit new combos for review on the site manageUsers - can change the user permissions and user details of another user manageSiteContent - can change site settings, such as the parameters for what featured combos there are viewUsers - inspect, but not manage users","title":"User Permissions"},{"location":"frontend/SUMMARY.html","text":"Installation and setup Creating a new page Creating a component","title":"SUMMARY"},{"location":"frontend/components.html","text":"Components Create a vue component in the components directory. If it's a component specific to a page, nest it in a directory with the same name as the the page. The component name should be at least 2 words. This is a linting rule to prevent colliding with exisitng HTML DOM nodes.","title":"Creating a component"},{"location":"frontend/components.html#components","text":"Create a vue component in the components directory. If it's a component specific to a page, nest it in a directory with the same name as the the page. The component name should be at least 2 words. This is a linting rule to prevent colliding with exisitng HTML DOM nodes.","title":"Components"},{"location":"frontend/installation-and-setup.html","text":"Frontend App Setup The frontend uses Nuxt@v2 to create the app. Installation Requirements See the Getting Started instructions for details about installing node. Build Setup # serve with hot reload at localhost:3000, specify PORT=<whatever> to change the port $ npm run dev If you want to see how the app will behave in production, build and run it: # build for production (this will take a while) $ npm run build-frontend # runs the site in prod mode using the generated pages from the build-frontend step $ npm start For detailed explanation on how things work, check out Nuxt.js docs .","title":"Installation and setup"},{"location":"frontend/installation-and-setup.html#frontend-app-setup","text":"The frontend uses Nuxt@v2 to create the app.","title":"Frontend App Setup"},{"location":"frontend/installation-and-setup.html#installation-requirements","text":"See the Getting Started instructions for details about installing node.","title":"Installation Requirements"},{"location":"frontend/installation-and-setup.html#build-setup","text":"# serve with hot reload at localhost:3000, specify PORT=<whatever> to change the port $ npm run dev If you want to see how the app will behave in production, build and run it: # build for production (this will take a while) $ npm run build-frontend # runs the site in prod mode using the generated pages from the build-frontend step $ npm start For detailed explanation on how things work, check out Nuxt.js docs .","title":"Build Setup"},{"location":"frontend/pages.html","text":"Pages Create a vue component in the pages directory, where the name of the file is the path a user will navigate to in the url. In general, try to keep page logic simple. Pull any complex logic out into a component in the components directory in a folder with the same name as the route.","title":"Creating a new page"},{"location":"frontend/pages.html#pages","text":"Create a vue component in the pages directory, where the name of the file is the path a user will navigate to in the url. In general, try to keep page logic simple. Pull any complex logic out into a component in the components directory in a folder with the same name as the route.","title":"Pages"},{"location":"testing/integration-testing.html","text":"Integration Testing Our integration tests use Cypress as our test runner. What to test Unlike unit tests, we really only want to test broad strokes behavior. The most common usages of the app, to ensure the functionality of the app remains unbroken. How to Run the Tests Run the firebase emulator. See the Emulators section of the Firebase documentation for details on how to set it up. npm run firebase:emulate Run the app npm run dev Run the tests npm run cy:run Videos/Screenshots By default, because it takes so long to process video, we have the video and screenshot capabilities turned off. If it's useful to inspect the video of what happened after the tests run, you can append this config flag to the test command: npm run cy:run -- --config video=true,videoUploadOnPasses=true,screenshotOnRunFailure=true Test Users When the emulators start up, they import users and Firestore documents from the firebase-emulator-seed-data directory. You can log in as these users within integration tests by using the cy.login function with the id of the user you want to log in as. For instance, to log in as a basic user that has the default permissions for a user: cy . login ( \"basic-user\" ); Ids of available users to log in as: basic-user - a user with the initial permissions of a user that has just signed up unprovisioned-user - a user that has signed up, but has not completed the sign up process of picking a username email-not-verified - a user that has basic permissions, but has not verified their email site-settings-manager - a user that has basic permissions and can visit the site-settings page Updating Seed Data To update seed data, run the following command: npm run firebase:emulate -- --export-on-exit = backend/firebase-emulator-seed-data Now, any changes you make (adding users, updating documents, etc) will update the seed data that the emulators use once you stop the emulator process. Adding new test users TODO: make a script that can do this programatically With the export flag set, add a user locally in the site. Set whatever permissions/data are necessary for this test user. (TODO, update instructions once managing user permissions is a thing) Stop the emulator process (ctrl + c in the pane running it, typically) Open ./firebase-emualtor-seed-data/auth_export/accounts.json and find your user Update the localId for your user with an id that explains what the user is. Add it to the list of available users in the documentation above. Re-run the emulate command with the export flag Look up the user in user-profiles. Delete the old id and create a new id with the localId chosen Look up the user in usernames. Update the userId field with the localId chosen Commit the change for the new test user. Typically, you'll also add a test for the user.","title":"Integration Testing"},{"location":"testing/integration-testing.html#integration-testing","text":"Our integration tests use Cypress as our test runner.","title":"Integration Testing"},{"location":"testing/integration-testing.html#what-to-test","text":"Unlike unit tests, we really only want to test broad strokes behavior. The most common usages of the app, to ensure the functionality of the app remains unbroken.","title":"What to test"},{"location":"testing/integration-testing.html#how-to-run-the-tests","text":"Run the firebase emulator. See the Emulators section of the Firebase documentation for details on how to set it up. npm run firebase:emulate Run the app npm run dev Run the tests npm run cy:run","title":"How to Run the Tests"},{"location":"testing/integration-testing.html#videosscreenshots","text":"By default, because it takes so long to process video, we have the video and screenshot capabilities turned off. If it's useful to inspect the video of what happened after the tests run, you can append this config flag to the test command: npm run cy:run -- --config video=true,videoUploadOnPasses=true,screenshotOnRunFailure=true","title":"Videos/Screenshots"},{"location":"testing/integration-testing.html#test-users","text":"When the emulators start up, they import users and Firestore documents from the firebase-emulator-seed-data directory. You can log in as these users within integration tests by using the cy.login function with the id of the user you want to log in as. For instance, to log in as a basic user that has the default permissions for a user: cy . login ( \"basic-user\" ); Ids of available users to log in as: basic-user - a user with the initial permissions of a user that has just signed up unprovisioned-user - a user that has signed up, but has not completed the sign up process of picking a username email-not-verified - a user that has basic permissions, but has not verified their email site-settings-manager - a user that has basic permissions and can visit the site-settings page","title":"Test Users"},{"location":"testing/integration-testing.html#updating-seed-data","text":"To update seed data, run the following command: npm run firebase:emulate -- --export-on-exit = backend/firebase-emulator-seed-data Now, any changes you make (adding users, updating documents, etc) will update the seed data that the emulators use once you stop the emulator process.","title":"Updating Seed Data"},{"location":"testing/integration-testing.html#adding-new-test-users","text":"TODO: make a script that can do this programatically With the export flag set, add a user locally in the site. Set whatever permissions/data are necessary for this test user. (TODO, update instructions once managing user permissions is a thing) Stop the emulator process (ctrl + c in the pane running it, typically) Open ./firebase-emualtor-seed-data/auth_export/accounts.json and find your user Update the localId for your user with an id that explains what the user is. Add it to the list of available users in the documentation above. Re-run the emulate command with the export flag Look up the user in user-profiles. Delete the old id and create a new id with the localId chosen Look up the user in usernames. Update the userId field with the localId chosen Commit the change for the new test user. Typically, you'll also add a test for the user.","title":"Adding new test users"},{"location":"testing/unit-testing.html","text":"Unit Testing We use jest as our test runner. Any new features added will need to be thoroughly unit tested. If you are unfamiliar with unit testing, but want to make a change, go ahead and open a PR and ask for help getting unit tests set up for your feature.","title":"Unit Testing"},{"location":"testing/unit-testing.html#unit-testing","text":"We use jest as our test runner. Any new features added will need to be thoroughly unit tested. If you are unfamiliar with unit testing, but want to make a change, go ahead and open a PR and ask for help getting unit tests set up for your feature.","title":"Unit Testing"}]}; var __search = { index: Promise.resolve(local_index) }